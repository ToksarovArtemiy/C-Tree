Работу выполнил: Токсаров Артемий ИТ-11

# **Симметризация дерева**

## Содержание
 - [Задача](#задача)
 - [Структкра проекта](#структура-проекта)
 - [Руководство по запуску](#руководство-по-запуску)
 - [Реализованные классы/структуры](#реализованные-классы/структуры)
 - [Методы и функции реализованные в программе](#методы-и-функции-реализованные-в-программе)
 - [Основной алгоритм](#основной-алгоритм)

## **Задача**

Дано бинарное дерево. Лесник может отрезать ветки (узлы), чтобы сделать дерево симметричным.
Дерево считается симметричным, если левое и правое поддеревья зеркально идентичны.
Каждый удалённый узел считается как 1 единица работы лесника.

Найти минимальное количество отрезаемых веток (узлов), чтобы дерево стало зеркально симметричным. 
Вывести количество отрезанных лесником листьев (количество удалённых узлов).

## **Структура проекта**
1. Tree.h - заголовочный файл для классов
2. Tree.cpp - файл с кодом методов классов
3. main.cpp - основной файл с точкой входа в программу

## **Руководство по запуску**
1. Нужно иметь любой среду разработки С++
2. В проект в среде разработки добавить три основных файла (указаны в структуре проекта)
3. Если нужно вводить дерево из файла, то необходимо добавить ещё один текстовый файл, в который занесены любые целые числа через пробел
4. Запустить программу

## **Реализованные классы/структуры**
1. TreeNode - отвечает за узел дерева
2. MakeTree - отвечает за создание дерева3
3. TreeOperations - отвечает за работу с деревом и симметризацию

## **Методы и функции реализованные в программе**
### Класс MakeTree (построение деревьев)
1. ```randTree(int maxDepth, int currentDepth = 0)```:Рекурсивно генерирует случайное бинарное дерево заданной максимальной глубины.
С вероятностью 30% прекращает ветвление на каждом уровне.

2. ```checkInput(string input)``` -Проверяет, является ли строка числом.

3. ```Insert(TreeNode* node, int value)``` -Вставляет новый узел с заданным значением в дерево поиска.

4. ```buildTreeFromInput()``` -Строит дерево поиска из чисел, введённых пользователем (до команды Q).

5. ```buildTreeFromFile(string filename)``` -Строит дерево поиска из чисел из файла.

### Класс TreeOperations (операции с деревьями)
6. ```countNodes(TreeNode* node)``` -Рекурсивно подсчитывает количество узлов в поддереве.

7. ```cloneTree(TreeNode* node)``` -Создаёт копию дерева.

8. ```deleteTree(TreeNode* node)``` -Рекурсивно удаляет все узлы дерева (освобождает память).

9. ```Height(TreeNode* root)``` -Вычисляет высоту дерева.

10. ```makeSymmetric(TreeNode*& a, TreeNode*& b)``` -Рекурсивно делает два поддерева симметричными, возвращая количество удалённых узлов.

11. ```makeTreeSymmetric(TreeNode* root)```- Делает всё дерево симметричным. Возвращает общее количество удалённых узлов.

12. ```printTreeVertical(TreeNode* root)```- Выводит дерево в вертикально.
### Дополнительные функции
13. ```displayMenu()```-Выводит текстовое меню с вариантами действий

## Основной алгоритм
### Функция makeTreeSymmetric
Делает всё дерево симметричным, начиная с корня. На вход получает root (указатель на корень дерева).
1. Проверка на пустое дерево: если root == nullptr, возвращаем 0 (дерево уже симметрично).
2. Обработка корня с двумя поддеревьями:
    - Если у корня есть оба поддерева (root->left и root->right):
         - Вызываем makeSymmetric(root->left, root->right), чтобы сделать их зеркальными.
         - Результат (количество удалённых узлов) записываем в cuts.
3. Обработка корня с одним поддеревом:
    - Если есть только левое поддерево (root->left):
         - Считаем количество узлов в нём (countNodes(root->left)).
         - Удаляем его (deleteTree(root->left)).
         - Обнуляем указатель (root->left = nullptr).
    - Если есть только правое поддерево (root->right):
         - Аналогично удаляем его и записываем количество удалённых узлов.
4. Возврат результата: возвращаем общее количество удалённых узлов (cuts).
### Функция makeSymmetric
Рекурсивно делает два поддерева зеркально симметричными, подсчитывая количество удалённых узлов. На вход получает указатели a и b на левое и правое поддеревья.
1. Проверка на пустые поддеревья:
     - Если оба узла a и b пусты (nullptr), возвращаем 0 (ничего удалять не нужно).
2. Обработка отсутствия одного из поддеревьев:
     - Если a отсутствует (nullptr):
          - Считаем количество узлов в поддереве b (countNodes(b)).
          - Удаляем всё поддерево b (deleteTree(b)).
          - Обнуляем указатель b = nullptr.
          - Возвращаем количество удалённых узлов (cuts).
     - Если b отсутствует (nullptr):
          - Аналогично считаем и удаляем поддерево a.
3. Рекурсивная обработка зеркальных поддеревьев:
     - Вызываем makeSymmetric(a->left, b->right) (левое поддерево a сравнивается с правым поддеревом b).
     - Вызываем makeSymmetric(a->right, b->left) (правое поддерево a сравнивается с левым поддеревом b).
     - Суммируем количество удалённых узлов (cuts += ...).
4. Возврат результата: возвращаем общее количество удалённых узлов (cuts).
## Тестирование
![image](https://github.com/user-attachments/assets/6cc467f5-934e-4952-aeaf-2503161c0112)
![image](https://github.com/user-attachments/assets/091e59c2-4f9c-4728-80f7-5b4b350c2a9f)

![image](https://github.com/user-attachments/assets/c2bdb327-276f-41a7-9539-95fe8964aafb)






