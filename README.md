Работу выполнил: Токсаров Артемий ИТ-11

# **Симметризация дерева**

## **Задача**

Дано бинарное дерево. Лесник может отрезать ветки (узлы), чтобы сделать дерево симметричным.
Дерево считается симметричным, если левое и правое поддеревья зеркально идентичны.
Каждый удалённый узел считается как 1 единица работы лесника.

Найти минимальное количество отрезаемых веток (узлов), чтобы дерево стало зеркально симметричным. 
Вывести количество отрезанных лесником листьев (количество удалённых узлов).

## **Структура проекта**
1. Tree.h - заголовочный файл для классов
2. Tree.cpp - файл с кодом методов классов
3. main.cpp - основной файл с точкой входа в программу

## **Руководство по запуску**
1. Нужно иметь любой среду разработки С++
2. В проект в среде разработки добавить три основных файла
3. Если нужно вводить дерево из файла, то необходимо добавить ещё один текстовый файл, в который занесены любые целые числа через пробел
4. Запустить программу

## **Реализованные классы/структуры**
1. TreeNode - отвечает за узел дерева
2. MakeTree - отвечает за создание дерева3
3. TreeOperations - отвечает за работу с деревом и симметризацию

## **Методы и функции, реалиованные в программе**
### Класс MakeTree (построение деревьев)
1. randTree(int maxDepth, int currentDepth = 0):Рекурсивно генерирует случайное бинарное дерево заданной максимальной глубины.
С вероятностью 30% прекращает ветвление на каждом уровне.

2. checkInput(string input) -Проверяет, является ли строка числом.

3. Insert(TreeNode* node, int value) -Вставляет новый узел с заданным значением в дерево поиска.

4. buildTreeFromInput() -Строит дерево поиска из чисел, введённых пользователем (до команды Q).

5. buildTreeFromFile(string filename) -Строит дерево поиска из чисел из файла.

### Класс TreeOperations (операции с деревьями)
6. countNodes(TreeNode* node) -Рекурсивно подсчитывает количество узлов в поддереве.

7. cloneTree(TreeNode* node) -Создаёт копию дерева.

8. deleteTree(TreeNode* node) -Рекурсивно удаляет все узлы дерева (освобождает память).

9. Height(TreeNode* root) -Вычисляет высоту дерева.

10. makeSymmetric(TreeNode*& a, TreeNode*& b) -Рекурсивно делает два поддерева симметричными, возвращая количество удалённых узлов.

11. makeTreeSymmetric(TreeNode* root)- Делает всё дерево симметричным. Возвращает общее количество удалённых узлов.

12. printTreeVertical(TreeNode* root)- Выводит дерево в вертикально.
### Дополнительные функции
13. displayMenu()-Выводит текстовое меню с вариантами действий





