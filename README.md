Работу выполнил: Токсаров Артемий ИТ-11

# **Симметризация дерева**

## **Задача**

Дано бинарное дерево. Лесник может отрезать ветки (узлы), чтобы сделать дерево симметричным.
Дерево считается симметричным, если левое и правое поддеревья зеркально идентичны.
Каждый удалённый узел считается как 1 единица работы лесника.

Найти минимальное количество отрезаемых веток (узлов), чтобы дерево стало зеркально симметричным. 
Вывести количество отрезанных лесником листьев (количество удалённых узлов).

## **Структура проекта**
1. Tree.h - заголовочный файл для классов
2. Tree.cpp - файл с кодом методов классов
3. main.cpp - основной файл с точкой входа в программу

## **Руководство по запуску**
1. Нужно иметь любой среду разработки С++
2. В проект в среде разработки добавить три основных файла
3. Если нужно вводить дерево из файла, то необходимо добавить ещё один текстовый файл, в который занесены любые целые числа через пробел
4. Запустить программу

## **Реализованные классы/структуры**
> TreeNode - отвечает за узел дерева
> MakeTree - отвечает за создание дерева
> TreeOperations - отвечает за работу с деревом и симметризацию

## **Методы и функции, реалиованные в программе**
### Класс MakeTree (построение деревьев)
> randTree(int maxDepth, int currentDepth = 0):Рекурсивно генерирует случайное бинарное дерево заданной максимальной глубины.
С вероятностью 30% прекращает ветвление на каждом уровне.

> checkInput(string input) -Проверяет, является ли строка числом.

> Insert(TreeNode* node, int value) -Вставляет новый узел с заданным значением в дерево поиска.

> buildTreeFromInput() -Строит дерево поиска из чисел, введённых пользователем (до команды Q).

> buildTreeFromFile(string filename) -Строит дерево поиска из чисел из файла.

### Класс TreeOperations (операции с деревьями)
> countNodes(TreeNode* node) -Рекурсивно подсчитывает количество узлов в поддереве.

> cloneTree(TreeNode* node) -Создаёт копию дерева.

> deleteTree(TreeNode* node) -Рекурсивно удаляет все узлы дерева (освобождает память).

> Height(TreeNode* root) -Вычисляет высоту дерева.

> makeSymmetric(TreeNode*& a, TreeNode*& b) -Рекурсивно делает два поддерева симметричными, возвращая количество удалённых узлов.

> makeTreeSymmetric(TreeNode* root)- Делает всё дерево симметричным. Возвращает общее количество удалённых узлов.

> printTreeVertical(TreeNode* root)- Выводит дерево в вертикально.
### Дополнительные функции
> displayMenu()-Выводит текстовое меню с вариантами действий





